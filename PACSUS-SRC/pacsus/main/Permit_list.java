package pacsus.main;

import java.util.ArrayList;
import java.util.Hashtable;

/* Generated by Together */

/**
 * Permit list manages the collection of permits currently issued and not yet
 * cancelled (or expired). It handles most of the use cases in the
 * Administration section. Note that each Permit must have a unique permit
 * holder name (so a HashTable is probably a good implementation of the
 * collection, with permit holder name as key).
 *
 * There will only be one instance of this class.
 */
public class Permit_list
{
    /**
     * The Permit list maintains a collection of the Permits currently issued.
     *
     * This association must be implemented by an attribute holding a collection
     * data structure (for example: array, hash table - the latter is recommended).
     *
     * Note that no two Permits may have the same permit holder name (this
     * information is not represented diagrammatically).
     * 
     * @associates Permit
     * @label Contains
     * @clientCardinality 1
     * @supplierCardinality 0..*
     * @directed
     */
    private java.util.Hashtable<String, Permit> lnkPermit;

    /**
     * Constructor for the Permit_list class, initialises a new HashTable
     */
    public Permit_list()
    {
	lnkPermit = new Hashtable<String, Permit>();
    }

    /**
     * A method to add a new permit to the list checking if it hasn't already been
     * added. Returning a true or false if it is/is not in the Table
     * 
     * @param key - The key for the HashTable, Permit Holder
     * @param p   - The Permit to be added
     * @return true/false - if it has or has not been added
     */
    public boolean add(String key, Permit p)
    {
	if (!lnkPermit.containsKey(key))
	{
	    lnkPermit.put(key, p);

	    return true;
	}

	else
	    return false;
    }

    /**
     * A method which gets an array of Strings to be used in the UI.
     * 
     * @return a String array of Permits.toString()
     */
    public String[] populateList()
    {
	ArrayList<Permit> allPermits = getPermitsByType("");

	String[] strings = new String[allPermits.size()];

	for (int i = 0; i < strings.length; i++)
	{
	    strings[i] = "" + allPermits.get(i).toString();
	}

	return strings;
    }

    /**
     * Returns the size of the HashTable
     * 
     * @return the size of the HashTable
     */
    public int size()
    {
	return lnkPermit.size();
    }

    /**
     * A public method which takes in the key value for the permit, finds the
     * associated permit and either removes or adds a warning.
     * 
     * @param key  - The name of the permit holder
     * @param type - value to check if adding or removing a permit
     */
    public void warnings(String key, int type)
    {
	if (type == 1)
	{
	    if (lnkPermit.get(key).getWarnings() < 3)
	    {
		lnkPermit.get(key).setWarnings(1);
	    }
	}

	else
	{
	    if (lnkPermit.get(key).getWarnings() > 0)
	    {
		lnkPermit.get(key).setWarnings(-1);
	    }
	}
    }

    /**
     * Find a permit with the given key, and remove it's warnings to unsuspend it.
     * 
     * @param key - The permit holder
     */
    public void unsuspendPermit(String key)
    {
	if (lnkPermit.get(key).getWarnings() == 3)
	{
	    lnkPermit.get(key).setWarnings(-3);
	}
    }

    /**
     * A method to reset any warnings on the Permit found by the key.
     * 
     * @param key - the Permit holder
     */
    public void resetWarnings(String key)
    {
	if (lnkPermit.get(key).getWarnings() >= 1)
	{
	    lnkPermit.get(key).setWarnings(-lnkPermit.get(key).getWarnings());
	}
    }

    /**
     * Returns the Permit associated with the key passed in
     * 
     * @param key - The Permit holder
     * 
     * @return the Permit associated
     */
    public Permit getPermit(String key)
    {
	return lnkPermit.get(key);
    }

    /**
     * A method to update the Permit when it has been edited. Returns a true or
     * false if the permit has been edited.
     * 
     * @param key - the permit holder
     * @param p   - the edited permit
     * 
     * @return true/false - if the permit was successfully edited
     */
    public boolean update(String key, Permit p)
    {
	if (lnkPermit.containsKey(key))
	{
	    lnkPermit.replace(key, p);
	    return true;
	}
	else
	{
	    return false;
	}
    }

    /**
     * Removes a value from the hashtable with a key
     * 
     * @param key Name of the Permit holder
     * @return True: if the value has been removed. False: if it hasn't.
     */
    public boolean deletePermit(String key)
    {
	if (lnkPermit.remove(key) != null)
	{
	    return true;
	}
	return false;
    }

    /**
     * A method to get the permits by type. It uses the HashTable forEach method to
     * iterate through the Collection to find the classes by type. It then adds any
     * Permits found, of the asked type to an ArrayList<Permit> and returns it so
     * they can be manipulated elsewhere.
     * 
     * @param permitType - A string of what Permit class is to be found.
     * 
     * @return an ArrayList of the Permits held of that type.
     */
    public ArrayList<Permit> getPermitsByType(String permitType)
    {
	ArrayList<Permit> list = new ArrayList<Permit>();
	lnkPermit.forEach((k, v) ->
	{
	    if (v.getClass().toString().contains(permitType))
	    {
		list.add(v);
	    }
	});
	return list;
    }

    /**
     * A blanket method to set all the permits hasEntered field as false on the
     * start of a new day
     */
    public void setPermitsHasEntered()
    {
	lnkPermit.forEach((k, v) ->
	{
	    v.setEnteredToday(false);
	});
    }

    /**
     * A method to remove the amount of entries on the change of year
     */
    public void removeEntries()
    {
	lnkPermit.forEach((k, v) ->
	{
	    v.setNoOfEntries(-v.getNoOfEntries());
	});

    }
}