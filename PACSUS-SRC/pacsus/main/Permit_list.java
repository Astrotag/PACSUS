package pacsus.main;

import java.util.ArrayList;
import java.util.Hashtable;

/* Generated by Together */

/**
 * Permit list manages the collection of permits currently issued and not yet
 * cancelled (or expired). It handles most of the use cases in the
 * Administration section. Note that each Permit must have a unique permit
 * holder name (so a HashTable is probably a good implementation of the
 * collection, with permit holder name as key).
 *
 * There will only be one instance of this class.
 */
public class Permit_list
{
    /**
     * The Permit list maintains a collection of the Permits currently issued.
     *
     * This association must be implemented by an attribute holding a collection
     * data structure (for example: array, hash table - the latter is recommended).
     *
     * Note that no two Permits may have the same permit holder name (this
     * information is not represented diagrammatically).
     * 
     * @associates Permit
     * @label Contains
     * @clientCardinality 1
     * @supplierCardinality 0..*
     * @directed
     */

    private java.util.Hashtable<String, Permit> lnkPermit;

    public Permit_list()
    {
	lnkPermit = new Hashtable<String, Permit>();
	// System.out.println(lnkPermit.toString());
    }

    public boolean add(String key, Permit p)
    {
	if (!lnkPermit.containsKey(key))
	{
	    lnkPermit.put(key, p);

	    return true;
	}

	else
	    return false;
    }

    public String[] populateList()
    {
	ArrayList<Permit> allPermits = getPermitsByType("");

	String[] strings = new String[allPermits.size()];

	for (int i = 0; i < strings.length; i++)
	{
	    strings[i] = "" + allPermits.get(i).toString();
	}

	return strings;
    }

    public int size()
    {
	return lnkPermit.size();
    }

    /**
     * A public method which takes in the key value for the permit, finds the
     * associated permit and either removes or adds a warning.
     * 
     * @param key  - The name of the permit holder
     * @param type - value to check if adding or removing a permit
     */
    public void warnings(String key, int type)
    {
	if (type == 1)
	{
	    if (lnkPermit.get(key).getWarnings() < 3)
	    {
		lnkPermit.get(key).setWarnings(1);
	    }
	}

	else
	{
	    if (lnkPermit.get(key).getWarnings() > 0)
	    {
		lnkPermit.get(key).setWarnings(-1);
	    }
	}

	// For testing purposes
	// System.out.println(lnkPermit.get(key) + " " +
	// lnkPermit.get(key).getWarnings());
    }

    public void unsuspendPermit(String key)
    {

	if (lnkPermit.get(key).getWarnings() == 3)
	{
	    lnkPermit.get(key).setWarnings(-3);
	}

	// For testing purposes
	// System.out.println(lnkPermit.get(key) + " " +
	// lnkPermit.get(key).getWarnings());
    }

    public Permit getPermit(String key)
    {
	return lnkPermit.get(key);
    }

    public boolean update(String key, Permit p)
    {
	if (lnkPermit.containsKey(key))
	{
	    lnkPermit.replace(key, p);
	    return true;
	}
	else
	{
	    return false;
	}
    }

    /**
     * Removes a value from the hashtable with a key
     * 
     * @param key Name of the Permit holder
     * @return True: if the value has been removed. False: if it hasn't.
     */
    public boolean deletePermit(String key)
    {
	if (lnkPermit.remove(key) != null)
	{
	    return true;
	}
	return false;
    }

    public ArrayList<Permit> getPermitsByType(String permitType)
    {
	ArrayList<Permit> list = new ArrayList<Permit>();
	lnkPermit.forEach((k, v) ->
	{
	    if (v.getClass().toString().contains(permitType))
	    {
		list.add(v);
		System.out.println("Added");
	    }
	    
	});
	return list;
    }

    public void yearReset()
    {
	// TODO add a call to the day reset once implemented
	Object ks[] = lnkPermit.keySet().toArray();
	for (Object o : ks)
	{

	    if (lnkPermit.get(o.toString()).isSuspended())
	    {
		lnkPermit.get(o.toString()).setSuspended(false);
	    }

	    if (lnkPermit.get(o.toString()).getWarnings() >= 1)
	    {
		lnkPermit.get(o.toString()).setWarnings(0);
	    }

	    if (lnkPermit.get(o.toString()).getNoOfEntries() >= 1)
	    {
		lnkPermit.get(o.toString()).setNoOfEntries(0);

	    }

	}

	// System.out.println("year reset");
    }

    public void setPermitsHasEntered()
    {
	lnkPermit.forEach((k, v) ->
	{
	    v.setEnteredToday(false);
	});
    }
}